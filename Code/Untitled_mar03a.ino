#include "arduino_secrets.h"

/*
  Sketch generated by the Arduino IoT Cloud Thing "Untitled"
  https://create.arduino.cc/cloud/things/b1db28a0-2e1f-4838-b8c9-9c43e511dc25

  Arduino IoT Cloud Variables description

  The following variables are automatically generated and updated when changes are made to the Thing

  CloudLight room1;
  CloudSwitch doorSwitch;
  int mq2;
  int waterlevel;

  Variables which are marked as READ/WRITE in the Cloud Thing will also have functions
  which are called when their values are changed from the Dashboard.
  These functions are generated with the Thing and added at the end of this sketch.
*/
int LDR_Val = 0;     /*Variable to store photoresistor value*/
int sensor =32;      /*Analogue Input for photoresistor*/


#include <SPI.h>
#include <MFRC522.h>
#include <ESP32Servo.h>

#define waterPumpRelay 12   
#define waterSensorSignalPin  35  
#define MAXTHRESHOLD   2000 // The threshold for water detectiion
#define MINTHRESHOLD 300


#define MOTION_SENSOR_PIN  26  // ESP32 pin GPIO22 connected to the OUTPUT pin of motion sensor
#define LIGHT_RELAY_PIN    13  // ESP32 pin GPIO26 connected to Relay's pin
int motionStateCurrent  = LOW;
int light1status = 0;
int doorstatus = 0;

#include "thingProperties.h"


const int mq2analogPin = 34;
const int fanRelay = 21;
const int buzzer = 4;

#define DOOR_SDA_PIN    5   // GPIO5 (D5) for SS
#define DOOR_RST_PIN   27  // GPIO18 (D18) for RST
#define SERVO_PIN 22  // GPIO13 (D13) for servo

int angle1 = 0;
#define SERVO_PIN1 14

MFRC522 rfid(DOOR_SDA_PIN, DOOR_RST_PIN); // Create MFRC522 instance
Servo servo;    //mq2               // Create servo instance
Servo servo1;  //door

byte authorizedUID[4] = {0x9A, 0x10, 0xF0, 0x81};
int angle = 0; // the current angle of servo motor


unsigned long previousMillis = 0;
const long delayInterval = 5000; // Set the delay interval in milliseconds


unsigned long previousMillis1 = 0;
const long delayInterval1 = 2000; // Set the new delay interval in milliseconds


void setup() {
  // Initialize serial and wait for port to open:
  Serial.begin(9600);
  delay(1500);



  pinMode(waterPumpRelay,   OUTPUT); // configure D2 pin as an OUTPUT
  pinMode(waterSensorSignalPin, INPUT);
  digitalWrite(waterPumpRelay, HIGH); // turn the pump OF
  pinMode(mq2analogPin, INPUT);
  pinMode(fanRelay, OUTPUT);
  pinMode(buzzer, OUTPUT);


  pinMode(MOTION_SENSOR_PIN, INPUT); // set ESP32 pin to input mode
  pinMode(LIGHT_RELAY_PIN, OUTPUT);        // set ESP32 pin to output mode

  SPI.begin(); // Init SPI bus
  rfid.PCD_Init(); // Init MFRC522
  servo1.attach(SERVO_PIN);
  servo.write(angle); // Rotate servo motor to 0°
  
   servo.attach(SERVO_PIN1);
  servo.write(angle1);

  Serial.println("Tap RFID/NFC Tag on reader");



  initProperties();

  // Connect to Arduino IoT Cloud
  ArduinoCloud.begin(ArduinoIoTPreferredConnection);

  /*
     The following function allows you to obtain more information
     related to the state of network and IoT Cloud connection and errors
     the higher number the more granular information you’ll get.
     The default is 0 (only errors).
     Maximum is 4
  */
  setDebugMessageLevel(2);
  ArduinoCloud.printDebugInfo();
}


void kitchenfireorotection()
{
  int sensorValue = analogRead(mq2analogPin); // Read analog value from MQ2 sensor
  mq2 = sensorValue;
  float voltage = (sensorValue / 4095.0) * 3.3; // Convert to voltage (assuming 12-bit ADC)

  Serial.println("MQ2 Sensor Value: ");
  Serial.print(sensorValue);
  Serial.print(", Voltage: ");
  Serial.print(voltage);
  Serial.print("V");

  if (sensorValue > 2000) {
    Serial.println("Gas detected!");

    digitalWrite(buzzer, HIGH);

    digitalWrite(fanRelay, HIGH);
    //digitalWrite(KitchenLightRelay, HIGH);

    Serial.println("Fan Relay on");
    
     if (angle1 == 0)
         { angle1 = 180;
           servo.write(angle1);
        Serial.println("Rotate Servo Motor to ");
        Serial.print(angle1);
        Serial.print("°");
         
         } 
      

       


    // Turn on LED if gas is detected
  } else {
    Serial.println("No gas detected");
    digitalWrite(buzzer, LOW);

    digitalWrite(fanRelay, LOW); // Turn off LED if no gas is detected
    Serial.println("FAN Relay Off");
    
    
    if (angle1 == 180)
    {
      angle1 = 0;
     servo.write(angle1);
    }
    
  }

  //delay(1000); // Wait for a second
}


void LDR() {
  /*Display LDR Output Val on serial monitor*/
    if(LDR_Val > 100) {       /*If light intensity is HIGH*/
        Serial.println(" High intensity ");
    }
    else {
     /*Else if Light intensity is LOW LED will Remain ON*/
        Serial.println("LOW Intensity ");
    }
}

void tankwatermanagement()
{
  int value = analogRead(waterSensorSignalPin); // read the analog value from sensor
  waterlevel = value;
  Serial.println(value);

  //digitalWrite(POWER_PIN, HIGH);   // turn the water sensor's power OFF

  if (value <= MINTHRESHOLD) {

    Serial.println("The tank has low water");
    Serial.println("The pump is on");

    digitalWrite(waterPumpRelay, LOW);  // turn the pump ON
    delay(1000);
     digitalWrite(waterPumpRelay, HIGH);  
  } 
  else if(value >= MAXTHRESHOLD){
    digitalWrite(waterPumpRelay, HIGH);   // turn the pump OFF
    Serial.println("The pump is off");

  }
  else
  {
    digitalWrite(waterPumpRelay, HIGH);  
  }

  // delay(1000); //
}


void light() {
  motionStateCurrent = digitalRead(MOTION_SENSOR_PIN); // read new state
  LDR_Val = analogRead(sensor);   // Analog read LDR value
  Serial.print("LDR Output Value: ");
  Serial.println(LDR_Val);

  if (light1status == 0) {
    if (motionStateCurrent == HIGH && LDR_Val < 2000) {
      // pin state change: LOW -> HIGH
      Serial.println("Motion detected!, turns pir relay ON");
      digitalWrite(LIGHT_RELAY_PIN, HIGH);
      previousMillis = millis(); // Store the current time
    } else {
      // pin state change: HIGH -> LOW
      unsigned long currentMillis = millis();
      if (currentMillis - previousMillis >= delayInterval) {
        Serial.println("Motion stopped!, turns pir relay OFF");
        digitalWrite(LIGHT_RELAY_PIN, LOW);
      }
    }
  }
}



void door1() {
  if(doorstatus == 0)
  {
  if (rfid.PICC_IsNewCardPresent()) { // New tag is available
    if (rfid.PICC_ReadCardSerial()) { // NUID has been read
      MFRC522::PICC_Type piccType = rfid.PICC_GetType(rfid.uid.sak);

      if (rfid.uid.uidByte[0] == authorizedUID[0] &&
          rfid.uid.uidByte[1] == authorizedUID[1] &&
          rfid.uid.uidByte[2] == authorizedUID[2] &&
          rfid.uid.uidByte[3] == authorizedUID[3]) {
        Serial.println("Authorized Tag");

        // Change angle of servo motor
        servo1.write(180);
        Serial.println("Rotate Servo Motor to ");
        Serial.println(180);
        Serial.print("°");

        // Store the current time using the new variable
        previousMillis1 = millis();
      } else {
        Serial.println("Unauthorized Tag with UID:");
        for (int i = 0; i < rfid.uid.size; i++) {
          Serial.println(rfid.uid.uidByte[i] < 0x10 ? " 0" : " ");
          Serial.println(rfid.uid.uidByte[i], HEX);
        }
        Serial.println();
      }

      rfid.PICC_HaltA();      // Halt PICC
      rfid.PCD_StopCrypto1(); // Stop encryption on PCD

      // Check if the new delay interval has elapsed
      unsigned long currentMillis = millis();
      if (currentMillis - previousMillis1 >= delayInterval1) {
        servo1.write(0);
        digitalWrite(buzzer, HIGH);
        delay(100);
        digitalWrite(buzzer, LOW);
      }
    }
  }
  }
}

void door() {
  if(doorstatus == 0)
  {
  if (rfid.PICC_IsNewCardPresent()) { // New tag is available
    if (rfid.PICC_ReadCardSerial()) { // NUID has been read
      MFRC522::PICC_Type piccType = rfid.PICC_GetType(rfid.uid.sak);

      if (rfid.uid.uidByte[0] == authorizedUID[0] &&
          rfid.uid.uidByte[1] == authorizedUID[1] &&
          rfid.uid.uidByte[2] == authorizedUID[2] &&
          rfid.uid.uidByte[3] == authorizedUID[3] ) {
        Serial.println("Authorized Tag");

        /*Change angle of servo motor
          if (angle == 0)
          angle = 180;
          else //if(angle == 90)
        angle = 180;*/

        // Control servo motor according to the angle
        servo1.write(180);
        Serial.println("Rotate Servo Motor to ");
        Serial.println(180);
        Serial.print("°");
        delay(2000);
        servo1.write(0);
          
          
      digitalWrite(buzzer,HIGH);
      delay(100);
      digitalWrite(buzzer,LOW);
      
      
      } else {
        Serial.println("Unauthorized Tag with UID:");
        for (int i = 0; i < rfid.uid.size; i++) {
          Serial.println(rfid.uid.uidByte[i] < 0x10 ? " 0" : " ");
          Serial.println(rfid.uid.uidByte[i], HEX);
          
      digitalWrite(buzzer,HIGH);
      delay(100);
      digitalWrite(buzzer,LOW);
      
        }
        Serial.println();
      }

      rfid.PICC_HaltA(); // Halt PICC
      rfid.PCD_StopCrypto1(); // Stop encryption on PCD
    }
  }
}
}



void loop() {
 kitchenfireorotection();
 door();

 LDR();
    light();
 tankwatermanagement();


  ArduinoCloud.update();



}



void onRoom1Change()  {
  if (room1 == 1)
  {
    digitalWrite(LIGHT_RELAY_PIN, HIGH); // Add your code here to act upon Room1 change
    light1status = 1;
  }
  else
  {
    digitalWrite(LIGHT_RELAY_PIN, LOW);
    light1status = 0;
  }
}


void onDoorSwitchChange()  {
  
  if (doorSwitch)
  {
     servo1.write(180);
   doorstatus =1;
  }
  else
  {
  
    servo1.write(0);
    doorstatus =0;
  }
  
  
  
  
}